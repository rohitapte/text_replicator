August 2007
A good programmer working intensively on his own code can hold it
in his mind the way a mathematician holds a problem he's working
on.  Mathematicians don't answer questions by working them out on
paper the way schoolchildren are taught to.  They do more in their
heads: they try to understand a problem space well enough that they
can walk around it the way you can walk around the memory of the
house you grew up in.  At its best programming is the same.  You
hold the whole program in your head, and you can manipulate it at
will.
That's particularly valuable at the start of a project, because
initially the most important thing is to be able to change what
you're doing.  Not just to solve the problem in a different way,
but to change the problem you're solving.
Your code is your understanding of the problem you're exploring.
So it's only when you have your code in your head that you really
understand the problem.
It's not easy to get a program into your head.  If you leave a
project for a few months, it can take days to really understand it
again when you return to it.  Even when you're actively working on
a program it can take half an hour to load into your head when you
start work each day.  And that's in the best case.  Ordinary
programmers working in typical office conditions never enter this
mode.  Or to put it more dramatically, ordinary programmers working
in typical office conditions never really understand the problems
they're solving.
Even the best programmers don't always have the whole program they're
working on loaded into their heads.   But there are things you can
do to help:
It's striking how often programmers manage to hit all eight points
by accident.  Someone has an idea for a new project, but because
it's not officially sanctioned, he has to do it in off hours—which
turn out to be more productive because there are no distractions.
Driven by his enthusiasm for the new project he works on it for
many hours at a stretch.  Because it's initially just an
experiment, instead of a "production" language he uses a mere
"scripting" language—which is in fact far more powerful.  He
completely rewrites the program several times; that wouldn't be
justifiable for an official project, but this is a labor of love
and he wants it to be perfect.  And since no one is going to see
it except him, he omits any comments except the note-to-self variety.
He works in a small group perforce, because he either hasn't told
anyone else about the idea yet, or it seems so unpromising that no
one else is allowed to work on it.  Even if there is a group, they
couldn't have multiple people editing the same code, because it
changes too fast for that to be possible.  And the project starts
small because the idea
small at first; he just has some cool
hack he wants to try out.
Even more striking are the number of officially sanctioned projects
that manage to do
.  In fact, if you look at
the way software gets written in most organizations, it's almost
as if they were deliberately trying to do things wrong. In a sense,
they are.  One of the defining qualities of organizations since
there have been such a thing is to treat individuals as interchangeable
parts.  This works well for more parallelizable tasks, like fighting
wars.  For most of history a well-drilled army of professional
soldiers could be counted on to beat an army of individual warriors,
no matter how valorous.  But having ideas is not very parallelizable.
And that's what programs are: ideas.
It's not merely true that organizations dislike the idea of depending
on individual genius, it's a tautology.  It's part of the definition
of an organization not to.  Of our current concept of an organization,
at least.
Maybe we could define a new kind of organization that combined the
efforts of individuals without requiring them to be interchangeable.
Arguably a market is such a form of organization, though it may be
more accurate to describe a market as a degenerate case—as what
you get by default when organization isn't possible.
Probably the best we'll do is some kind of hack, like making the
programming parts of an organization work differently from the rest.
Perhaps the optimal solution is for big companies not even to try
to develop ideas in house, but simply to
them.  But regardless
of what the solution turns out to be, the first step is to realize
there's a problem.  There is a contradiction in the very phrase
"software company."   The two words are pulling in opposite directions.
Any good programmer in a large organization is going to be at odds
with it, because organizations are designed to prevent what
programmers strive for.
